---
title: "Getting Started With OpenSearch"
date: 2026-01-08T15:38:46+13:00
draft: false
tags: ["ai", "llm", "gemini", "automation"]
---

* Introduction
OpenSearch is a powerful, open-source search and analytics suite. Whether you are building a full-text search engine or a vector database for RAG (Retrieval-Augmented Generation), getting the basics right is crucial.

This guide covers setting up a local environment using Docker, managing indices, and implementing k-Nearest Neighbor (k-NN) vector search.

* 1. Installation via Docker
Running OpenSearch locally is straightforward with Docker. We will set up a single-node cluster and attach OpenSearch Dashboards (formerly Kibana) for visualization.



** Create a Network
First, create a dedicated bridge network so the node and dashboard can communicate.
#+begin_src bash
docker network create os-net
#+end_src

** Run OpenSearch Node
We will run a single node with security enabled (recommended even for dev).

- *Port 9200:* HTTP REST API
- *Port 9600:* Performance Analyzer
#+begin_src bash
docker run -d --name opensearch-node 
--network os-net 
-p 9200:9200 -p 9600:9600 
-e "discovery.type=single-node" 
-e "OPENSEARCH_INITIAL_ADMIN_PASSWORD=<password>" 
opensearchproject/opensearch:latest
#+end_src

** Verify Installation
#+begin_src bash

# Check cluster health

curl -X GET "https://localhost:9200/_cluster/health?pretty" -ku admin:"<password>"
#+end_src

* 2. Basic Data Operations (CRUD)
Once the server is up, we can interact with it using REST APIs.



** Inserting Data (Indexing)
You can define an ID explicitly (PUT) or let OpenSearch generate one (POST).

#+begin_src bash

# Create/Update document with ID 1

curl -ku admin:<password> -XPUT "https://localhost:9200/students/_doc/1" 

-H 'Content-Type: application/json' -d'
{
"name": "John Doe",
"gpa": 3.89,
"grad_year": 2022
}'
#+end_src

** Bulk Operations
For performance, use the `_bulk` API to insert multiple documents at once.
#+begin_src bash
curl -ku admin:<password> -XPOST "https://localhost:9200/_bulk" 

-H 'Content-Type: application/json' -d'
{ "create": { "_index": "students", "_id": "2" } }
{ "name": "Jonathan Powers", "gpa": 3.85, "grad_year": 2025 }
{ "create": { "_index": "students", "_id": "3" } }
{ "name": "Jane Doe", "gpa": 3.52, "grad_year": 2024 }
'
#+end_src

** Deleting Data
The distinction between deleting a document and an index is important:

- =DELETE /students/_doc/1=: Like shredding a single piece of paper from a folder.
- =DELETE /students=: Like throwing the entire filing cabinet into the trash.

* 3. Mappings and Analyzers
** Dynamic Mapping
By default, OpenSearch infers the schema. However, this can lead to incorrect types (e.g., `grad_year` becoming a `long` instead of a `date`).



To fix a mapping, you generally must:

1. Delete the old index.
2. Recreate the index with explicit mappings.
3. Re-index the data.

#+begin_src bash

# Explicit mapping creation

curl -ku admin:<password> -XPUT "https://localhost:9200/students" -H 'Content-Type: application/json' -d'
{
"mappings": {
"properties": {
"name": { "type": "text" },
"grad_year": { "type": "date" },
"gpa": { "type": "float" }
}
}
}'
#+end_src

** Analyzers
Analyzers split text into tokens (inverted index).

- Input: "Actions speak louder"
- Tokens: ~[action, speak, loud]~
This allows "speaking loudly" to match "Actions speak louder".

* 4. Vector Search (k-NN)



Vector search allows you to find "nearest neighbors" in a multi-dimensional space, which is essential for semantic search or recommendation systems.

** Step 1: Create a k-NN Index
We must enable `index.knn` and define the vector dimensions and space type (e.g., `l2` for Euclidean distance).

#+begin_src bash
curl -ku admin:<password> -XPUT "https://localhost:9200/hotels-index" 

-H 'Content-Type: application/json' -d'
{
"settings": {
"index.knn": true
},
"mappings": {
"properties": {
"location": {
"type": "knn_vector",
"dimension": 2,
"space_type": "l2"
}
}
}
}'
#+end_src

** Step 2: Ingest Vector Data
We insert data points (e.g., coordinates or embeddings generated by an app).
#+begin_src bash

# Bulk insert 2D coordinates

curl -ku admin:<password> -XPOST "https://localhost:9200/_bulk" 

-H 'Content-Type: application/json' -d'
{ "index": { "_index": "hotels-index", "_id": "1" } }
{ "location": [5.2, 4.4] }
{ "index": { "_index": "hotels-index", "_id": "2" } }
{ "location": [5.2, 3.9] }
{ "index": { "_index": "hotels-index", "_id": "3" } }
{ "location": [4.9, 3.4] }
'
#+end_src

** Step 3: Search
Find the 3 hotels closest to the coordinate `[5, 4]`.
#+begin_src bash
curl -ku admin:<password> -XPOST "https://localhost:9200/hotels-index/_search" 

-H 'Content-Type: application/json' -d'
{
"size": 3,
"query": {
"knn": {
"location": {
"vector": [5, 4],
"k": 3
}
}
}
}'
#+end_src

* 5. Filtering with Vectors
Sometimes you need to combine semantic search (meaning) with structured criteria (e.g., "shoes" that are "red").
1. *Efficient k-NN Filtering:* Applies the filter *during* the approximate search.
2. *Post-filtering:* Runs vector search first, then removes non-matching results (can reduce result size drastically).
3. *Exact Search:* Pre-filters documents and runs exact k-NN on the remainder.



