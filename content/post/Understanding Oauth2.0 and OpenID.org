---
title: "Understanding Oauth2.0 and OpenID"
date: 2025-09-18T12:30:13+12:00
draft: false 
---

It's completely normal to find OAuth 2.0 and OpenID confusing at first! (Yes, it's me!!) They deal with abstract concepts of "who you are" and "what you can do," and the terminology can be a lot to grasp. To help solidify that understanding for you and others, here is my post for beginners and me of future.

* Clearing the Fog: Understanding OAuth 2.0, OpenID, and Why They (Usually) Work Together

Have you ever clicked a "Login with Google" or "Connect with Facebook" button on a website or app? That seamless experience is powered by complex protocols behind the scenes. For many, these protocols – especially OAuth 2.0 and OpenID – can feel like a tangled mess of acronyms and redirects. You're not alone if you've struggled to tell them apart!
Let's demystify these essential tools for modern web security.

1) The Concept That Confused Us All: Authorization vs. Authentication
   The biggest stumbling block for many, myself included, is often confusing authorization with authentication. They sound similar, but in the world of web security, they serve distinctly different purposes:
   - Authentication (Who are you?): This is about verifying your identity. When you log in with a username and password, you are authenticating yourself. The system confirms that you are who you say you are.
   - Authorization (What can you do?): This is about granting permissions. Once you're authenticated, authorization determines what actions you're allowed to perform or what resources you can access. For example, you might be authorized to view a document, but not to edit it.
   *OAuth 2.0* is primarily an authorization protocol. It's about giving an application permission to do things on your behalf, like accessing your photos or reading your email, without ever giving that app your password.
   *OpenID*, on the other hand, is an authentication protocol. Its main job is to verify who you are and let you use that verified identity to log into different services. Think of it as a universal "Who am I?" badge.
   The confusion often arises because when you grant an application access (OAuth), the service providing that access usually also authenticates you in the process. This "pseudo-authentication" can make it seem like OAuth is doing both, but it's /crucial/ to remember its core focus is access delegation.
2) OAuth 2.0 vs. OpenID (and the Power of OpenID Connect!)
   Let's break down the key differences:
   #+begin_example
   |--------------+---------------------------------------------------------------------------------------+--------------------------------------------------------------------|
   | Feature      | Oauth2.0                                                                              | OpenID                                                             |
   |--------------+---------------------------------------------------------------------------------------+--------------------------------------------------------------------|
   | Primary Goal | Authorization / Access Delegation: What can an app do on your behalf?                 | Authentication / Identity Verification: Who are you? (SSO          |
   | Main Output  | An Access Token: A credential for the app to access resources                         | An Assertion of Identity: Confirmation of who the user is          |
   | Data Shared  | Grants specific, customizable access (scopes) to protected resources                  | Verifies end-user identity only                                    |
   | Complexity   | Generally more complex due to signed tokens and multi-step exchanges                  | Simpler protocol flow, does not use tokens for its primary purpose |
   | SSO Relation | Provides an SSO-like experience, but isn't built for identity verification on its own | Designed for Single Sign-On (SSO)                                  |
   |--------------+---------------------------------------------------------------------------------------+--------------------------------------------------------------------|
   #+end_example
   
   This is where things get really powerful. OpenID Connect (OIDC) is an authentication protocol that builds directly on top of OAuth 2.0. It cleverly combines the strengths of both:
   - It uses OAuth 2.0's secure flows for authentication requests and responses, enabling that seamless single sign-on experience we love.
   - It introduces an ID token (an OAuth 2.0 token, typically a JSON Web Token or JWT) that allows applications to verify your identity and access basic user information.
   So, if you want to both authenticate a user (who are you?) AND authorize an application (what can it do?), OpenID Connect is your go-to standard. It provides both identity verification and delegated authorization
3) A Closer Look at the Data Flow: Authorization Code Flow with PKCE
   The most recommended and secure OAuth 2.0 flow for web and mobile applications is the Authorization Code Flow with Proof Key for Code Exchange (PKCE). It protects against interception by adding an extra layer of security, especially for applications that can't securely store a client_secret (like single-page apps or mobile apps).
   Here's a simplified breakdown of the data moving around:
   Key Players:
   - User (Resource Owner): You, the person who owns the data.
   - Client Application (Client): The app or website you're using.
   - Authorization Server: The service that handles your login and grants permissions (e.g., Google's identity platform, Auth0).
   - Resource Server: The service that holds your actual data (e.g., Google Photos, your app's API).
   The Steps:
   1. User Initiates: You click "Login" on the Client Application.
   2. Client Prepares for PKCE: The Client App's SDK generates a unique, secret code_verifier (a random string) and a code_challenge (a hashed version of the code_verifier). The code_verifier is kept secret by the client.
   3. Client Requests Authorization: The Client Application redirects your browser to the Authorization Server's /authorize endpoint.
      - Data Sent: client_id, redirect_uri (where to send you back), response_type=code, scope (permissions requested), state (for security), code_challenge, code_challenge_method.
   4. User Authenticates & Consents: Your browser shows the Authorization Server's login page and a consent screen asking if you approve the Client App's requested permissions. You log in (to the Authorization Server, not the client!) and click "Approve".
   5. Authorization Server Redirects with Code: If approved, the Authorization Server generates a single-use authorization code, stores the code_challenge, and redirects your browser back to the Client Application's redirect_uri.
      - Data Sent: code (the authorization code), state (same one from step 3 for validation).
   6. Client Exchanges Code for Tokens (Server-to-Server): The Client Application (its backend) makes a direct, secure POST request to the Authorization Server's /oauth/token endpoint.
      - Data Sent: grant_type=authorization_code, client_id, code (from step 5), redirect_uri, and the secret code_verifier (from step 2).
      - Authorization Server Validates: It verifies the code and that the code_verifier matches the code_challenge it previously stored.
      - Data Received: If valid, the Authorization Server responds with an access_token (for resource access), an id_token (if OIDC is used, for user identity), and optionally a refresh_token (to get new access tokens later).
   7. Client Accesses Resources: The Client Application now uses the access_token to make API calls to the Resource Server (e.g., api.example.com/user/profile) to fetch your data.
      - Data Sent: API request with access_token in the Authorization: Bearer header.
      - Data Received: Your requested data.
   Wait!!!!
   The resource server always verifies the client with an access token? why? Here's how it works:
   1. Client Uses the Access Token: After successfully obtaining an access_token from the Authorization Server, the client application uses this token to make API calls to the Resource Server to access protected resources. The access_token is typically included in the Authorization header of these HTTP requests, usually in the format Authorization: Bearer <access_token>.
   2. Resource Server Verification of the Access Token: When the Resource Server receives a request with an access_token, it must validate the token to ensure it is legitimate and grants the necessary permissions. The sources describe two primary ways the Resource Server can do this:
      - Introspection (Communicating with the Authorization Server): One method is for the Resource Server to directly communicate with the OAuth server (Authorization Server) that originally created the token to validate it. This process is known as introspection. The Resource Server sends the access_token to an introspection endpoint on the Authorization Server, which then responds with information about the token's validity, expiration, and associated scopes.

      - Self-Contained Tokens (JWTs) and Cryptographic Signature Verification: Many OAuth servers use JSON Web Tokens (JWTs) as the format for access tokens. JWTs are JSON objects that contain "claims" (data) about the entity for whom the token was issued and are typically cryptographically signed by the Authorization Server. In this scenario, the Resource Server can verify the token's cryptographic signature using the Authorization Server's public key. By checking the signature, the Resource Server can confirm:
        - The token was indeed issued by the trusted Authorization Server.
        - The token's contents have not been tampered with. This method allows the Resource Server to validate the token without needing to contact the Authorization Server for every request ("phoning home").
   3. Does the Resource Server "Know" the Access Token is Correct? The Resource Server does not inherently "know" if an arbitrary access token is correct without performing a verification step. However, it operates on a basis of trust with the Authorization Server.
      - The Authorization Server is responsible for authenticating the user and, with the user's consent, issuing access tokens.

      - The Resource Server trusts the Authorization Server to issue valid and correctly formatted tokens.

      - Through either introspection or cryptographic signature verification (for JWTs), the Resource Server can confirm that a token was issued by a trusted Authorization Server and remains valid.
   4. Most access tokens are "bearer tokens". A bearer token is like a car key; "anyone who holds the key can start the car". This means if the token is valid, the Resource Server grants access based on the permissions encoded in the token, without necessarily verifying the identity of the client application beyond its possession of a valid token. For higher security, sender-constrained tokens (like those using mTLS or DPoP) can be used, where the token is "bound to a secret key" and the "client proves possession of the key when using the token," providing a stronger verification of the legitimate client
   
   
4) Where Do We Use Them? (Real-World Examples)
   * OAuth 2.0 (for Authorization):
     - Third-Party App Access: An app wants to post tweets on your behalf or access your cloud storage files.
     - API Protection: Companies like Google, Meta Platforms, Microsoft, and Amazon use OAuth 2.0 to protect their APIs, allowing other applications to securely interact with user data on their services.
     - Server-to-Server Communication (Client Credentials Flow): When one backend service needs to access another without any user involvement (e.g., a batch job updating user profiles).
   * OpenID Connect (OIDC) (for Authentication and SSO):
     - "Login with Google/Facebook/etc." Buttons: These are classic examples of OIDC at work, allowing you to use an existing account to sign into a new service.
     - Enterprise Single Sign-On: Letting employees log into multiple internal applications using a single company identity
Hopefully, this breakdown has helped clear up any remaining confusion and gives you a solid foundation for understanding OAuth 2.0 and OpenID Connect! It's a complex but incredibly important part of modern web security.   
