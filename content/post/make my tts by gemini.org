---
title: "Generating Audio from Text with Google's Gemini API"
date: 2025-08-06T13:45:38+12:00
draft: false
---

* Introduction
As a non-native speaker, I often find myself in a tricky spot during calls or remote conferences. It can be quite challenging to fully grasp every nuance when multiple non-native speakers are involved, and honestly, it's something I've felt a bit ashamed about. Despite loving to engage in conversations and discussions, this communication barrier has definitely been a pain point for me.
To tackle this, I've explored a couple of ideas:

- /Google NotebookLM/ for Scripts: I tried feeding speaker scripts into Google NotebookLM. It's truly awesome how it can regenerate new conversations and even create a podcast or video based on the script, showing a good understanding of the story. The only drawback is that it doesn't always stick to the exact original script.
- /Google Cloud TTS API/: I also experimented with the Google Cloud Text-to-Speech (TTS) API. While it converts text quite well within its request limits, I found the voices to be a bit unnatural or "odd."
- Gemini API: Given that Gemini is a multimodal LLM, I had a strong feeling it could offer a much better solution. Its advanced capabilities seemed promising for generating more natural-sounding audio while maintaining the integrity of the original text. *So, I decided to give it a try!*
  
This blog post explores how to use Google's Gemini API to generate audio from text. A Python script that reads text from a file, sends it to the Gemini API, and saves the resulting audio to a file. You can create a more robust and user-friendly audio generation application.

* Code Overview
The provided Python script performs the following steps:

1.  *Reads Text*: Reads a specified number of lines from a text file.
2.  *Generates Audio*: Sends the text to the Gemini API to generate audio.
3.  *Saves Audio*: Saves the received audio data to a file, handling different MIME types and converting to WAV format if necessary.

* Code
#+begin_src python
  # To run this code you need to install the following dependencies:
  # pip install google-genai

  import base64
  import mimetypes
  import os
  import re
  import struct
  from google import genai
  from google.genai import types
  import time

  def read_n_lines(file_path, n=3):
      linen = []
      try:
          with open(file_path, 'r') as f:        
              while True:
                  tmpLine=""
                  for i in range(n):
                      line1 = f.readline()
                      if not line1:
                          linen.append(tmpLine)
                          return linen
                      tmpLine += line1[:-1]
                  print(tmpLine[:15]+"...")    
                  print("text length: ", len(tmpLine))
                  linen.append(tmpLine)
          
      except FileNotFoundError:
          print(f"Error: File not found at {file_path}")

      return linen
      


  def save_binary_file(file_name, data):
      f = open(file_name, "wb")
      f.write(data)
      f.close()
      print(f"File saved to to: {file_name}")

  file_index = 0
  def generate(mytext):
      client = genai.Client(
          api_key=os.environ.get("GOOGLE_API_KEY"),
      )

      #model = "gemini-2.5-pro-preview-tts"
      model = "gemini-2.5-flash-preview-tts"
      contents = [
          types.Content(
              role="user",
              parts=[
                  types.Part.from_text(text=mytext),
              ],
          ),
      ]
      generate_content_config = types.GenerateContentConfig(
          temperature=1,
          response_modalities=[
              "audio",
          ],
          speech_config=types.SpeechConfig(
              voice_config=types.VoiceConfig(
                  prebuilt_voice_config=types.PrebuiltVoiceConfig(
                      voice_name="Zephyr"
                  )
              )
          ),
      )

      global file_index
      for chunk in client.models.generate_content_stream(
          model=model,
          contents=contents,
          config=generate_content_config,
      ):
          if (
              chunk.candidates is None
              or chunk.candidates[0].content is None
              or chunk.candidates[0].content.parts is None
          ):
              continue
          if chunk.candidates[0].content.parts[0].inline_data and chunk.candidates[0].content.parts[0].inline_data.data:
              file_name = f"ENTER_FILE_NAME_{file_index}"
              file_index += 1
              inline_data = chunk.candidates[0].content.parts[0].inline_data
              data_buffer = inline_data.data
              file_extension = mimetypes.guess_extension(inline_data.mime_type)
              if file_extension is None:
                  file_extension = ".wav"
                  data_buffer = convert_to_wav(inline_data.data, inline_data.mime_type)
              save_binary_file(f"{file_name}{file_extension}", data_buffer)
          else:
              print(chunk.text)

  def convert_to_wav(audio_data: bytes, mime_type: str) -> bytes:
      """Generates a WAV file header for the given audio data and parameters.

      Args:
          audio_data: The raw audio data as a bytes object.
          mime_type: Mime type of the audio data.

      Returns:
          A bytes object representing the WAV file header.
      """
      parameters = parse_audio_mime_type(mime_type)
      bits_per_sample = parameters["bits_per_sample"]
      sample_rate = parameters["rate"]
      num_channels = 1
      data_size = len(audio_data)
      bytes_per_sample = bits_per_sample // 8
      block_align = num_channels * bytes_per_sample
      byte_rate = sample_rate * block_align
      chunk_size = 36 + data_size  # 36 bytes for header fields before data chunk size

      # http://soundfile.sapp.org/doc/WaveFormat/

      header = struct.pack(
          "<4sI4s4sIHHIIHH4sI",
          b"RIFF",          # ChunkID
          chunk_size,       # ChunkSize (total file size - 8 bytes)
          b"WAVE",          # Format
          b"fmt ",          # Subchunk1ID
          16,               # Subchunk1Size (16 for PCM)
          1,                # AudioFormat (1 for PCM)
          num_channels,     # NumChannels
          sample_rate,      # SampleRate
          byte_rate,        # ByteRate
          block_align,      # BlockAlign
          bits_per_sample,  # BitsPerSample
          b"data",          # Subchunk2ID
          data_size         # Subchunk2Size (size of audio data)
      )
      return header + audio_data

  def parse_audio_mime_type(mime_type: str) -> dict[str, int | None]:
      """Parses bits per sample and rate from an audio MIME type string.

      Assumes bits per sample is encoded like "L16" and rate as "rate=xxxxx".

      Args:
          mime_type: The audio MIME type string (e.g., "audio/L16;rate=24000").

      Returns:
          A dictionary with "bits_per_sample" and "rate" keys. Values will be
          integers if found, otherwise None.
      """
      bits_per_sample = 16
      rate = 24000

      # Extract rate from parameters
      parts = mime_type.split(";")
      for param in parts: # Skip the main type part
          param = param.strip()
          if param.lower().startswith("rate="):
              try:
                  rate_str = param.split("=", 1)[1]
                  rate = int(rate_str)
              except (ValueError, IndexError):
                  # Handle cases like "rate=" with no value or non-integer value
                  pass # Keep rate as default
          elif param.startswith("audio/L"):
              try:
                  bits_per_sample = int(param.split("L", 1)[1])
              except (ValueError, IndexError):
                  pass # Keep bits_per_sample as default if conversion fails

      return {"bits_per_sample": bits_per_sample, "rate": rate}


  if __name__ == "__main__":
      for text in read_n_lines("script.txt", 15):
          if text:
              time.sleep(10)
              generate(text)

#+end_src


* Code Breakdown

Let's examine the key functions in detail.

**Function: `read_n_lines(file_path, n=3)`**

#+begin_src python
  def read_n_lines(file_path, n=3):
      linen = []
      try:
          with open(file_path, 'r') as f:        
              while True:
                  tmpLine=""
                  for i in range(n):
                      line1 = f.readline()
                      if not line1:
                          linen.append(tmpLine)
                          return linen
                      tmpLine += line1[:-1]
                  print(tmpLine[:15]+"...")    
                  print("text length: ", len(tmpLine))
                  linen.append(tmpLine)
          
      except FileNotFoundError:
          print(f"Error: File not found at {file_path}")

      return linen
#+end_src

This function reads the file in chunks of *n* lines. I didn't make error handling and exception handler. 
- *Handling empty lines:* The original code removes the last character (`line1[:-1]`) which can lead to problem when the line is empty.
- *Error handling:* It could also handle other exceptions like `IOError`.
- *Return None:* Return `None` when error occurs.

**Function: `save_binary_file(file_name, data)`**

#+begin_src python
  def save_binary_file(file_name, data):
      """Saves binary data to a file."""
      try:
          with open(file_name, "wb") as f:
              f.write(data)
          print(f"File saved to: {file_name}")
      except IOError as e:
          print(f"Error saving file: {e}")
#+end_src

**Function: `generate(mytext)`**

#+begin_src python
  file_index = 0
  def generate(mytext):
      client = genai.Client(
          api_key=os.environ.get("GOOGLE_API_KEY"),
      )

      #model = "gemini-2.5-pro-preview-tts"
      model = "gemini-2.5-flash-preview-tts"
      contents = [
          types.Content(
              role="user",
              parts=[
                  types.Part.from_text(text=mytext),
              ],
          ),
      ]
      generate_content_config = types.GenerateContentConfig(
          temperature=1,
          response_modalities=[
              "audio",
          ],
          speech_config=types.SpeechConfig(
              voice_config=types.VoiceConfig(
                  prebuilt_voice_config=types.PrebuiltVoiceConfig(
                      voice_name="Zephyr"
                  )
              )
          ),
      )

      global file_index
      for chunk in client.models.generate_content_stream(
          model=model,
          contents=contents,
          config=generate_content_config,
      ):
          if (
              chunk.candidates is None
              or chunk.candidates[0].content is None
              or chunk.candidates[0].content.parts is None
          ):
              continue
          if chunk.candidates[0].content.parts[0].inline_data and chunk.candidates[0].content.parts[0].inline_data.data:
              file_name = f"MY_Voice_file_{file_index}"
              file_index += 1
              inline_data = chunk.candidates[0].content.parts[0].inline_data
              data_buffer = inline_data.data
              file_extension = mimetypes.guess_extension(inline_data.mime_type)
              if file_extension is None:
                  file_extension = ".wav"
                  data_buffer = convert_to_wav(inline_data.data, inline_data.mime_type)
              save_binary_file(f"{file_name}{file_extension}", data_buffer)
          else:
              print(chunk.text)
#+end_src

This function interacts with the Gemini API to generate audio from the provided text. It sets up the API client, content, and generation configuration. The audio chunks are then processed and saved to files.

**Function: `convert_to_wav(audio_data: bytes, mime_type: str) -> bytes`**

#+begin_src python
  def convert_to_wav(audio_data: bytes, mime_type: str) -> bytes:
      """Generates a WAV file header for the given audio data and parameters.

      Args:
          audio_data: The raw audio data as a bytes object.
          mime_type: Mime type of the audio data.

      Returns:
          A bytes object representing the WAV file header.
      """
      parameters = parse_audio_mime_type(mime_type)
      bits_per_sample = parameters["bits_per_sample"]
      sample_rate = parameters["rate"]
      num_channels = 1
      data_size = len(audio_data)
      bytes_per_sample = bits_per_sample // 8
      block_align = num_channels * bytes_per_sample
      byte_rate = sample_rate * block_align
      chunk_size = 36 + data_size  # 36 bytes for header fields before data chunk size

      # http://soundfile.sapp.org/doc/WaveFormat/

      header = struct.pack(
          "<4sI4s4sIHHIIHH4sI",
          b"RIFF",          # ChunkID
          chunk_size,       # ChunkSize (total file size - 8 bytes)
          b"WAVE",          # Format
          b"fmt ",          # Subchunk1ID
          16,               # Subchunk1Size (16 for PCM)
          1,                # AudioFormat (1 for PCM)
          num_channels,     # NumChannels
          sample_rate,      # SampleRate
          byte_rate,        # ByteRate
          block_align,      # BlockAlign
          bits_per_sample,  # BitsPerSample
          b"data",          # Subchunk2ID
          data_size         # Subchunk2Size (size of audio data)
      )
      return header + audio_data
#+end_src

This function converts audio data of a specific MIME type to WAV format by prepending a WAV header.

**Improvements and Considerations:**

- *Robustness*: The parsing logic is relatively simple. Consider using a more robust MIME type parsing library if you need to handle a wider variety of formats.

* Main execution block

#+begin_src python
  if __name__ == "__main__":
      for text in read_n_lines("script.txt", 15):
          if text:
              time.sleep(10)
              generate(text)
#+end_src

